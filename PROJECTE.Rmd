---
title: "PROJECTE"
author: "Carles Aguilera"
date: "2025-10-08"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

```{r}
df <- read.csv("RealEstate_Georgia.csv")
View(df)
```


# Data  preparation

The first step of a data science project involves cleaning the raw data set. In this section we address how to deal with missing values, correcting inconsistencies and transformating the data into a format suitable for algorithms. Therefore, in this section, we will study each variable in order to clean as much as possible the dataset for the future results to be as acurate as possible.

## Variable 1: stateId

The variable stateId is nominal since it represents a state category. Since the value never changes, this variable does not provide information to any statistical model. Therefore, it is typically removed.
```{r}
summary(df$stateId)
which(df$stateId != "16")
df <- subset(df, select = -stateId)
```

## Variable 2: countyId

The variable countyId is a nominal variable that represents the identifier for each country a house is in. If we also see the variable Country, we might see some inconsistencies. This identifier should be representing each country, but if we see the variable Country, we can see there is only one possible value (which is USA). This inconsistency lead us to removing this variable as well as the country variable since we already know that this dataset is from USA, specifically in Georgia, so we can ommit this type of data, since it doesn't add any useful information.

**REVISAR**: countyId != countryId. És útil el countyId per a predir price?

**DETALL** : countyID pot ser que estigui relacionat amb county --> però em dona la sensació que countyID va més al detall, en canvi country engloba més (un nivell d'agreggació superior).

```{r}
table(df$countyId)
df$coun
which(table(df$countyId) > 1)
which(table(df$countyId) > 2)
# IN THAT CASE WE OBSERVE WITH THAT TABLE AND THIS CONDIITONS THAT EACH VALUE APPEARS ONLY ONE TIME, AND SOMETIMES TWO TIMES, BUT NO MORE THAN 2
#df <- subset(df, select = -countyId)
```

## Variable 3: cityId

**REVISAR**: Ens hem de quedar o amb cityId o amb City. Depenent de què fem, és un o l'altre.

**DETALL** JO PERSONALMENT EM QUEDARIA AMB CITY, EL ID TAMPOC ENS DONARÀ GAIRE INFORMACIÓ, PERÒ EL NOM PODER SI QUE ENS INTERESSA MÉS. A L'HORA DE FER TEST ENTRE DIFERENTS CIUTATS I TREURE'N CONCLUSIONS.

## Variable 4: Country

The variable county is a nominal variable representing the county of each house. Since the country of all the houses in the dataset is USA, we can remove that variable since it doesn't add useful information.

```{r}
which(df$country != "USA")
df <- subset(df, select = -country)
```

## variable 5: datePostedString

The variable datePostedString is a nominal variable that represents the date when the house was published. From the instructions of this practice, we can see that we need to retain the observations that were posted on **2021 only**.

```{r}
df$datePostedString <- as.Date(df$datePostedString, format = "%Y-%m-%d")
df$datePostedString <- as.numeric(format(df$datePostedString, "%Y"))
size_out_of_year <- which(df$datePostedString != 2021); length(size_out_of_year)
df <- df[df$datePostedString == 2021,]
```

**REVISAR** AQUEST FRAGMENT DE CODI, PER A QUÈ ÉS??

```{r}
str(df)

df$datePostedString <- as.Date(df$datePostedString, format = "%Y-%m-%d")
df$datePostedString <- as.numeric(format(df$datePostedString, "%Y"))
length(df[which(df$datePostedString == 2021),]$datePostedString)
df$stateId <- as.factor(df$stateId)
which(df$stateId == '16')

# Donat que algunes de les columnes tenen els mateixos valors, les eliminarem perquè no ens proporcionene en informació rellevant.
df <- df[-c('hasBadGeocode', '')]
df 
View(df)
which(df$currency != 'USD')

```


# variable 6 IS_BANK_OWNED.

This variable indicates whether the property belongs to the bank or not. Therefore, it provides information about the bank ownership of the property.
Since it is a binary variable, we consider it more appropriate to treat it as a categorical (qualitative) variable, distinguishing two categories: Yes and No, depending on whether the property is bank-owned or not.

For this reason, we analyzed this variable to identify which values correspond to bank-owned properties and which do not, confirming that there are only two possible values (0 and 1). Finally, we transformed the variable into a categorical variable with these two levels.

```{r}
str(df$is_bankOwned)
which(df$is_bankOwned > 1 | df$is_bankOwned < 0) 

# SO THAT MEANS, AS WE CAN SEE IN THE PREVIEW, THAT THIS VARIABLE IS NUMERIC BUT CAN BE                                     CONSIDERED AS CATEGORICAL, AND WE THINK THAT IS THE BEST OPTION, TO CONSIDER AS A                                         CATEGORICAL VARIABLE.

which(df$is_bankOwned == 1)
which(df$is_bankOwned != 0)
boxplot(df$is_bankOwned)

"LET'S TRANSFORM THAT VARIABLE TO A CATEOGIRCAL / FACTOR VARIABLE."

df$is_bankOwned <- factor(df$is_bankOwned, labels = c("NO", "YES"))

```


# variable 7 IS_FOR_AUCTION

This variable indicates whether a given house is being auctioned or not. In this case, the treatment applied is very similar to the one used previously: we checked for variability between the values 0 and 1, in order to confirm that there are houses that are auctioned and others that are not.
Once this variability was confirmed, we proceeded to transform the variable into a categorical one, assigning two levels: Yes and No, depending on whether the house belongs to an auction or not.

```{r}
str(df$is_forAuction)

which(df$is_forAuction < 0 | df$is_forAuction > 1)
which(df$is_forAuction != 0)
boxplot(df$is_forAuction)
"WE HAVE THE SAME CASE AS BEFORE, SO LET'S TRANSFORM THAT VARIABLE TO A CATEGORICAL / FACTOR VARIABLE. "

df$is_forAuction <- factor(df$is_forAuction, labels = c("NO", "YES"))
```

**REVISAR** EN AMBDOS CASSOS, VARIABLE 6 I 7, TENIM UN UNIC VALOR DIFERENT A LA RESTA, COM HO TRACTARIEM EN AQUEST CAS? 
JO PER MI HO DEIXEM, PERÒ AL SER NOMÉS UN, NO SEMBLA SOSPITOS, JUST NOMÉS UN ÚNIC CAS EN CADA UN ? 

# variable 8 event

This variable indicates the condition of the house. It is relevant information, as it allows us to know the current state of the property at any time. Therefore, we consider it important to keep this variable for further analyses.

In addition, one of the tasks performed was to convert this variable from type char to type factor, in order to analyze in future studies whether the condition of the house has any impact or relationship with its price.

```{r}
str(df$event)
table(df$event)
# MAYBE THAT VARIABLE IS INTERESTING FOR FURTHER ANALYSIS IN DATA, LET'S TAKE AND WE'LL NOT ERASE IT.
sum(is.na(df$event))

# WE DON'T HAVE MISSING VALUES, SO THAT'S PERFECT ALSO. 
# MAYBE IT'S INTERESTING TO CONVERT TO FACTOR
df$event <- as.factor(df$event)
```


# variable 9 TIME

IN THAT CASE, THE TIME FOR THE TARGET VARIABLE THAT IS PRICE, DOESN'T CONTRIBUTE, SO WE CAN EREASE IT. 

We have no specific interest in knowing the exact moment when the listing was published or when the house was for sale. We consider that this information is not essential for studying the property price.
Therefore, it is not necessary to keep the temporal variable related to the listing or sale time of the house. 

```{r}
df <- subset(df, select = -time)
```

# variable 10 PRICE

Price is the target variable, so it is critical. First, we will assess its data quality: ensure there are no missing values and that the records are consistent. Next, we will evaluate whether the price distribution is approximately normal and examine the presence of outliers.

Because price is the dependent variable in our study, we will conduct a more in-depth analysis: describe its distribution, identify and justify outliers, and discuss which features (e.g., property condition, area, location, auction status, etc.) may explain these extreme values.

```{r}
str(df$price)
sum(is.na(df$price))

"ES UNA VARIABLE NUMERICA, COM ERA D'ESPERAR I NO TE MISSING VALUES, PER TANT, DE MOMENT SEMBLA QUE LA VARIABLE ESTÀ BÉ."

"LET'S SEE IF THERE IS A OUTLAYER IN THAT VARIABLE"
boxplot(df$price)
# YES, WE HAVE SOME OUTLAYERS, SO LET'S CHECK, WHICH ONE'S ARE MILD OR SEVERE OUTLAYERS.

sum_sq <- summary(df$price)
iqr <- sum_sq[5] - sum_sq[2]
llmild <- which(df$price < sum_sq[2] - 1.5*iqr | df$price > sum_sq[5] + 1.5*iqr) 
llsev <- which(df$price < sum_sq[2] - 3*iqr | df$price > sum_sq[5] + 3*iqr) 
length(llmild); length(llsev)

# SO IN THAT CASE WE HAVE TWO OUTLAYERS, LET'S SEE THAT OUTLAYERS

boxplot(df$price)
abline(h = sum_sq[2] - 1.5*iqr, col='green')
abline(h = sum_sq[5] + 1.5*iqr, col='green')
abline(h = sum_sq[2] - 3*iqr, col='red')
abline(h = sum_sq[5] + 3*iqr, col='red')

"PER TANT TENIM OUTLAYERS, LET'S CHECK ALL OF THESE OUTLAYERS"

df_copy <- df
df_copy$isout <- 0
df_copy$isout[c(llmild, llsev)] <- 1

df_copy$isout <- factor(df_copy$isout, labels = c("NO", "YES"))

str(df_copy)

var_col <- c(4:8,10,12,14,22,24,25,27,31,32,33,36,37); var_col
df_cat_res <- df_copy[,var_col]; df_cat_res

res.ct <- catdes(df_cat_res,
                 num.var = 17)

res.ct$quanti.var
res.ct$category
res.ct$quanti

```

SO IN THAT CASE, WE CAN OBSERVE THAT THE ONE'S THAT ARE OUTLAYERS IN THE PRICE VARIABLE ARE THOSE ONE'S THAT LIVE IN A CITY WHERE THE HOUSES ARE MORE EXPENSIVE THAN THE OTHERS ONE. 

ALSO WE CAN OBSERVE THAT THE THE ONE'S THAT ARE OUTLAYERS ARE THOSE ONE'S THAT THE PRICE IS HIGHER THAN THE OVERALL MEAN (10 TIMES MORE), AND OBVIUSLY, HIS LIVING AREA IS MORE EXPENSIVE, INCLUDING MORE BATHROOMS AND BEEDROMS, THAT MAKE SENSE, THE ONE'S THAT ARE MORE EXPENSIVE ARE THOSE ONE'S THAT ARE IN MORE EXPENSIVE AREAS AND ALSO ARE MORE BIGGER THAN THE NORMAL ONE'S.

#variable 11 price_per_square_foot

THAT VALUE IT'S INTERESTING BECAUSE IN FURTHER ANALYSIS, MAYBE WE HAVE A HUGE INTEREST TO KNOW
ABOUT HOW MUCH IT COSTS THE SQUARE_FOOT PER ZONE O PER COUNTRY, SO IN THAT CASE, WE THINK IT SHOULD BE IMPORTANT TO HAVE THAT VARIABLE FOR FUTURE ANALYSIS.

```{r}
sum_sq <- summary(df$pricePerSquareFoot)
boxplot(df$pricePerSquareFoot)

# LOOKING AT THIS, WEE HAVE A OUTLAYER, IN THAT CASE LET'S SEE WHICH IS THIS OUTLAYER. 
iqr <- sum_sq[5] - sum_sq[2]
llmild <- which(df$price < sum_sq[2] - 1.5*iqr | df$pricePerSquareFoot > sum_sq[5] + 1.5*iqr) 
llsev <- which(df$price < sum_sq[2] - 3*iqr | df$pricePerSquareFoot > sum_sq[5] + 3*iqr) 
length(llmild); length(llsev)

# SO IN THAT CASE WE HAVE TWO OUTLAYERS, LET'S SEE THAT OUTLAYERS

boxplot(df$pricePerSquareFoot)
abline(h = sum_sq[2] - 1.5*iqr, col='green')
abline(h = sum_sq[5] + 1.5*iqr, col='green')
abline(h=sum_sq[2] - 3*iqr, col='red')
abline(h=sum_sq[5] - 3*iqr, col='red')

# WE HAVE THIS TWO OUTLAYERS, SO LET'S SEE WHAT WE CAN DO WITH THESE OUTLAYERS.
# THOSE OUTLAYERS CORRESPON TO THAT ONE'S THAT ARE EXPENSIVE.

```



#variable 12 CITY.

WE THINK THAT CITY IS A IMPORTANT VARIABLE, BECAUSE, DEPENDING OF THE CITY, YOU CON MAKE SOME DEEP ANALYSIS AND UNDERSTAND AND FIND WHICH CITY OR ZONES ARE THE NOST EXPENSIVE OR CHEAPEST ONE'S, SO IN THAT CASE IT'S IMPORTANT TO MANTAIN THAT VRIABLE FOR FURTHER ANALYSIS. 

```{r}
table(df$city)
prop.table(table(df$city))
sum(is.na(df$city)) # we don't have any missing values.
```



#variable 13 state

IN THAT CASE WE HAVE THAT ALL OF THESE HOUSES ARE IN THE SAME STATE, SO THAT VARIABLE DOESN'T MAKE SENSE, IT DOESN'T GIVE ADDITIONAL INFORMATION AND IT'S REDUNDANT SO WE CAN ERASE IT FROM OUR DATASET. 

```{r}
which(df$state != "GA")
df <- subset(df, select = -state)
```



# variable 14 year_built

FOR THAT VARIABLE WE THINK THAT IT'S ALSO IMPORTANT TO KNOW FOR THE FURTHER ANALYSIS.
MAYBE, IN THE FUTURE, THE YEAR OF THE HOUSE IT'S SO IMPORTANT, SO THAT WILL MAKE A DIFFERENCE IN THE FINAL PRCIE, MAYBE NEW HOMES ARE MORE EXPENSIVE THAN THE OLDER ONE'S OR THE CONTRARY. 

```{r}
summary(df$yearBuilt)
boxplot(df$yearBuilt)

# we have also outlayers, so let's check carefully to see why these outlayers. 


```



# variable 15 STREET ADRESS. 

IN THAT CASE WE THINK THE STREET IT'S NOT IMPORTANT, THE STREET WILL NOT DETERMINE THE PRICE, WHAT'S REALLY IMPORTANT IS TO KNOWE THE CITY AN THE ZONE, BUT THE STREET DOESN'T MAKE ANY CONTRIBUTION FOR PREDICTING THE PRICE. 

HERE IN PEDRALBES, WE KNOW ALL THE HOUSES AND FLATS ARE VERY EXPENSIVE, BUT THE STREET DOESN'T PLAY ANY ROLE TO INCREMENT THAT PRCIE OR NOT, BUT THE ZONE --> PEDRALBES, YES, SO THAT'S WHY WE DELETE THAT VARIABLE.

```{r}
df <- subset(df, select = -streetAddress)
```


# variable 16 / 17 / 18.

IN THAT CASE WHAT HAPPENS IS THE SAME, WE DON'T REALLY WANT TO KNOW THE ZIPCODE OR THE LATITUDE OR LONGITUDE TO PREDICT OR TO KNOW THE PRICE, SO, WE MEAN THAT, THAT VARIABLES DOSEN'T GIVE TO US ANY CONTRIBUTION, WE KNOW FOR THE ZIPCODE THE CITY / COUNTRY, SO THAT'S ENOUGH TO UNDERSTAND IN FUTURE ANALYSIS WHICH CITY WE ARE TALKING ABOUT. ALSO THE LATTITUDE AND LONGITUDE IT'S NOT IMPORTANT, BECAUSE THAT WILL NOT GIVE TO ME MORE INFORMATION ABOUT THE PRICE FOR THE HOUSE, I HAVE THE CITY AND I DON'T WANT THE COORDINATES WHERE THE HOUSE IS. 

```{r}
df <- subset(df, select= -c(zipcode, latitude, longitude))
```

# variable 19. hasbadGeocdoe

IN THAT CASE WE HAVE a column that has a lot of same values, all the same -> 0. 
SO THAT COLUMN IS NOT GIVING TO US ADDITIONAL INFORMATION, ALL VALUES ARE THE SAME, WE CAN EREASE IT. 

```{r}
which(df$hasBadGeocode != 0)
df <- subset(df, select = -hasBadGeocode)
```

# variable 20. Currency


# variable 21. 

WE HAVE HERE ALSO THE SAME AS SOME VARIABLES IN THAT DATASET, WE HAVE A VARIABLE THAT IS NOT GIVING TO US ADDITIONAL INFORMATION, SO WHAT WE HAVE TO DO IS TO ERASE IT, BECAUSE I NOT GIVING MORE ADDITIONAL INFORMATION

```{r}
which(df$currency != 'USD')
df <- subset(df, select = -currency)
```

#variable 22 / 23 / 26 LIVING AREA & LIVING AREA VALUE & building area.



IN THAT CASE WE HAVE THREE VARIABLES THAT REPRESENTS THE SAME, SO HAVING BOTH OF THEM IS REDUNDANT SO IN THAT CASE WE WILL CHOOSE THE SECOND ONE, LIVING AREA VALUE.

```{r}
df <- subset(df, select = -livingArea)
df <- subset(df, select = -buildingArea)
```


# variable 24 BATHROOMS


```{r}
var_out <- summary(df$bathrooms)
boxplot(df$bathrooms)

iqr <- var_out[5] - var_out[2]

llm <- which(df$bathrooms < var_out[2] - 1.5*iqr | df$bathrooms > var_out[5] + 1.5*iqr); length(llm)
lls <- which(df$bathrooms < var_out[2] - 3*iqr | df$bathrooms > var_out[5] + 3*iqr); length(lls)

boxplot(df$bathrooms)
abline(h= var_out[2] - 1.5*iqr, col= 'green')
abline(h= var_out[5] + 1.5*iqr, col= 'green')
abline(h= var_out[2] - 3*iqr, col= 'red')
abline(h= var_out[2] + 3*iqr, col='red')

# tenim un total de 
length(llm) + length(lls) # -> 554 outlaiers. 520 mild i 34 de extreme. 
```


# variable 25 BEEDROMS

```{r}
var_out <- summary(df$bedrooms)
boxplot(df$bedrooms)

iqr <- var_out[5] - var_out[2]

llm <- which(df$bedrooms < var_out[2] - 1.5*iqr | df$bedrooms > var_out[5] + 1.5*iqr); length(llm)
lls <- which(df$bedrooms < var_out[2] - 3*iqr | df$bedrooms > var_out[5] + 3*iqr); length(lls)

boxplot(df$bedrooms)
abline(h= var_out[2] - 1.5*iqr, col= 'green')
abline(h= var_out[5] + 1.5*iqr, col= 'green')
abline(h= var_out[2] - 3*iqr, col= 'red')
abline(h= var_out[2] + 3*iqr, col='red')

# tenim un total de 
length(llm) + length(lls) # $413 outlayers. 
```



# variable 27 / 28 / 29  PARKING, HAS GARAGE , GARAGESPACES

HERE WE HAVE 3 VARIABLES THAT TALKS ABOUT THE PARKING, IN THAT CASE, WHAT IT'S REALLY IMPORTANT IS TO KNOW HOW MANY PLACES OF PARKING YOU HAVE, BECAUSE EACH PLACE COSTS MONEY, AND HAVING ONE OR TWO PLACES FOR PARKING, CHANGES THE PRICE, OBVIUSLY. ANDD HAVING NO ONE ALSO CHANGE THE PRICE, BUT IN THAT CASE WE HAVE THE 0 VALUE THAT REPRESENTS NO PARKING PLACE, AND THEN THE NUMBEROF ARKINGS THAT EACH HOUSE HAVE IT'S REALLY IMPORTANT AS WE MENTIONED ABOVE. 

IN ALL THIS 3 VARIABLES WE HAVE INCONSITENCY, SO WHICH ONE WE'LL CHOOSE ?? 

**REVISAR** QUÉ FEM PER SOLUCIONAR AQUESTES INCOSTIÈNCIES.

```{r}

```




# variable 30 LEVELS

THAT VARIABLE IS IMPORTANT, BECAUSE CAN GIVE TO US INFORMATION ABOUT WHICH LEVEL HAS EACH HOME.

```{r}
table(df$levels)
prop.table(table(df$levels))
sum(is.na(df$levels)) # WE DON'T HAVE ANY OUTLIER IN THAT CASE.
```

# VARIABLE 31 POOL

THAT IS SO IMPORTANT FOR THE PRICE, HAVING OR NO POOL IN THE HOUSE CAN CHANGE A LOT THE PRCIE OF THE HOME, SO IT'S AN IMPORTANT VARIABLE.

THE ONLY THINK THAT WE MUST TAKE INTO ACCOUNT IS THAT IS A NUMERIC (INT) VARIABLE, AND WE SHOULD CONVERT THAT TYPE OF DATA TO A FACTOR -> YES OR NO HAVE POOL, IT WILL BE EASIER TO WORK WITH THAT FACTOR VARIABLE. 

```{r}
str(df$pool)
which(df$pool < 0 | df$pool > 1) # we don't have any strange value
df$pool <- factor(df$pool, labels = c("NO", "YES"))
```


# VARIABLE 32 SPA

IN THAT VARIABLE HAPPENS THE SAME AS THE VARIABLE ABOVE, BECAUSE WHAT WE HAVE IS THE BINARY VALUE OF 0 OR 1, INDICATING IF THAT HOUSE HAS OR NOT SPA. ALSO IT'S AN IMPORTANT VARIABLE, BECAUSE HAS INFLUENCE IN THE FINAL PRICE.

```{r}
str(df$spa)
which(df$spa < 0 & df$spa > 1)
df$spa <- factor(df$spa, labels = c("NO", "YES"))
```


# VARIABLE 33 IS NEW CONSTRUCTION

THE SAME AS VARIABLES ABOVE. THE IMPORTANCE OF THAT VARIABLE MAY COME TO UNDERSTAND IF NEW HOUSES ARE MORE EXPENSIVE THAN THE OLDER ONE'S OR THE CONTRARY, SO WE THINK IT'S AN IMPORTANT VARIABLE.

```{r}
str(df$isNewConstruction)
which(df$isNewConstruction < 0 | df$isNewConstruction > 1)
df$isNewConstruction <- factor(df$isNewConstruction, c("NO", "YES"))
```

# VARIABLE 34 has pets allowed

THE SAME HAPPENS IN THAT VARIABLE, THE SAME AS ABOVE, IN THAT CASE **REVSAR** NO SE FINS A QUIN PUNT ES PODRIA CONSIDERAR SI ET POT TENIR PETS O NO...AL FINAL COMPRES LA CASA I FAS EL QUE VOLS, NO ? O PODER ES PER SI LA CASA ESTARIA ADAPTADA A ANIMALS DE COMPANYIA ??? **REVISAR**

```{r}
str(df$hasPetsAllowed)
which(df$hasPetsAllowed < 0 | df$hasPetsAllowed > 1)
which(df$hasPetsAllowed != 0)
df$hasPetsAllowed <- factor(df$hasPetsAllowed, c("NO", "YES"))
```

# VARIABLE 35 HOME_TYPE

```{r}
str(df$homeType)
sum(is.na(df$homeType)) # no missing values.

"WE MUST ALSO CONVERT THAT VARIABLE TO A FACTOR VARIABLE"
df$homeType <- as.factor(as.character(df$homeType))

table(df$homeType)
prop.table(table(df$homeType))
"WE have here that the most houses are from the single family --> 88% aprox"
```
# VARIABLE 36 COUNTY

HERE WE HAVE ALSO A VARIABLE, THAT IN THE PART OF THE VARIABLE 2 WE COMMENT THAT MAYBE WE ONLY WANT THE COUNTY ID OR MAYBE THAT VARIABLE COUNTY, **REVISAR** Y DECIDIR!!

```{r}
str(df$county)
sum(is.na(df$county)) # we don't have any missing value. 

df$county <- as.factor(as.character(df$county))

table(df$county)
prop.table(table(df$county))
```


#   FIRST DATA ANALYSIS

Un dels passos més importants es veure si la variable de resposta, és a dir, la variable target,
en aquest cas price, segueix una distribució normal o no, és a dir si es ditribuida normally o no. 
  
A partir d'aqui el que farem és un anàlisi tant grafic com també estadisitic per valorar la normalitat de la variable     target price. 
  
```{r}

hist(df$price)
qqnorm(df$price)
qqline(df$price)

# IN THAT CASE WE CAN'T SAY THAT IS NORMALLY DISTRIBUITED, BUT LET'S SEE IF WITH THE SHAPIRO.TEST THE RESULT IS THE SAME    OR NOT. 

#shapiro.test(df$price) # Problema, tenim massses!!!!!!!!!!!

"LET'S CHECK APPLAYING THE LOGARITMIC TRANSFORMATION"

hist(log(df$price))
qqnorm(log(df$price))
qqline(log(df$price))

```
  



# Detect univariate outlayers and multivariate outlayers. 

Una de les coses mes importants que hem de fer es considerar els univariate outlayers, ja que aquests, juntament amb els multivariate outlayers, són cassos estranys fora de la normalitat, i per tant, els haurem d'analitzar amb certa atenció per veure que esta succeïnt amb aquest valor més estrany del noistre conjunt de dades. 



  **MULTIVARIATE OUTLAYERS**
  
```{r}
library(chemometrics)
var_col_2 <- c(4:8,10,12,14,22,24,25,27,31,32,33,36,37); var_col_2
df_mout <- df_copy[,var_col]; df_mout
df_mout <- df_mout[,c(6,8:11)]
df_mout
res.mout <- Moutlier(df_mout)

plot(res.mout$md, res.mout$rd)
abline(h=res.mout$cutoff, col='red')
abline(v=res.mout$cutoff, col='red')
```

TAKING INTO ACCOUNT THE GRAPHIC, WE HAVE A HUGE, VERY HUGE MULTIVARIANT OUTLAYER. LET'S SEE WHICH ONE IS THAT ONE THAT IS THE MULTIVARIATE OUTLAYER.

```{r}
df_copy_2 <- df_mout
df_copy_2

df_copy_2$mvout <- 0
df_copy_2$mvout[which(res.mout$md > res.mout$cutoff & res.mout$rd > res.mout$cutoff)] <- 1

df_copy_2$mvout <- factor(df_copy_2$mvout, labels = c("MVout-NO", "MVout-yes"))
df_copy_2
cat <- catdes(df_copy_2,6)

cat$quanti.var
cat$quanti



```

IM THAT CASE WE OBSERVE THAT THE ONE'S WHO ARE MULTIARIATE OUTLAYER ARE THOSE ONE'S WHO HAVE MORE PRICE/BATHROOMS/BEDRROMS AND PRICE IN LIVING AREA.




# Errors and missing values


Una de les coses mes importants es corregir les parts amb certs errors o missing values. Hem de garantir en tot moment que les dades amb les que treballem tenen qualitat i que no hi han missing values. 

Per aquest motiu una de les coses més importants que hem de fer es corregir aquests errors i tractar-los. 

En aquest cas el que farem és ús d'una funció molt important que ja hem trebalalt amb ella varies vegades, de la llibreria de FactoMineR , que es la de mice, que ens permetra fer imputació de missing values, per assegurar que treballem amb dades de bona qualitat i que per tant, no hi han missing values. 





